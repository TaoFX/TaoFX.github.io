<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="写BUG小能手">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="写BUG小能手">
<meta property="og:locale">
<meta property="article:author" content="xuetaofeng">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/"/>





  <title>写BUG小能手</title>
  








<meta name="generator" content="Hexo 5.3.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">写BUG小能手</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/20/mysqldump%E7%9A%84%E4%BD%BF%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/12/20/mysqldump%E7%9A%84%E4%BD%BF%E7%94%A8/" itemprop="url">mysqldump的使用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-12-20T15:42:02+08:00">
                2022-12-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>简单的使用方式如下：</p>
<ol>
<li><p>导出整个数据库(包括数据库中的数据）<br>mysqldump -u username -p dbname &gt; dbname.sql</p>
</li>
<li><p>导出数据库结构（不含数据）<br>mysqldump -u username -p -d dbname &gt; dbname.sql</p>
</li>
<li><p>导出数据库中的某张数据表（包含数据）<br>mysqldump -u username -p dbname tablename &gt; tablename.sql</p>
</li>
<li><p>导出数据库中的某张数据表的表结构（不含数据）<br>mysqldump -u username -p -d dbname tablename &gt; tablename.sql</p>
</li>
</ol>
<p>如果需要按条件导出某个数据表的数据，可以使用 -w 参数指定where语句的条件。</p>
<p>比如导出<strong>A</strong>数据库的<strong>t_log</strong>的表结构和录入时间（lrsj字段，datetime类型）小于2022-12-02零点的数据：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -u root -p A t_log -w&quot;lrsj &lt; &#39;2022-12-02 00:00:00&#39;&quot; &gt; &#x2F;home&#x2F;test.sql</span><br></pre></td></tr></table></figure>
<p>注意，如果有个场景，需要按时间导出相应数据，而时间字段又是timestamp类型的。这时，mysqldump会在导出数据前，默认先设置时区为+00:00，然后再根据-w的语句进行筛选数据，这种情况下，可能会因为数据库和导出使用的时区不一样，导致使用相同条件，在数据库查到的数据行数和导出的不一致。<a target="_blank" rel="noopener" href="https://www.cnblogs.com/mr-totoro/p/5807636.html">参考文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/07/%E4%BD%BF%E7%94%A8DBeavar%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/12/07/%E4%BD%BF%E7%94%A8DBeavar%E8%BF%81%E7%A7%BB%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E8%BF%87%E7%A8%8B%E8%AE%B0%E5%BD%95/" itemprop="url">使用DBeavar迁移MySQL数据库的过程记录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-12-07T10:45:33+08:00">
                2022-12-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><p>登录数据库所在服务器，创建数据库，并赋权给相应用户。赋权命令参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wwppp987/article/details/123983250">点击跳转</a></p>
</li>
<li><p>使用DBeaver，导出数据表结构</p>
<p>选中需要导出的表，右击-&gt;生成SQL-&gt;DDL，然后就会弹出一个框，显示选中表的建表语句</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%E8%A1%A8%E7%BB%93%E6%9E%84.png"></p>
</li>
<li><p>导出表数据</p>
<p>选中需要导出的表，右击-&gt;导出数据，在弹出的框中一直点下一步，最后开始。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%95%B0%E6%8D%AE1.png"></p>
<p>其中，有如下地方需要修改。选择导出为SQL，选择写入到单个文件中。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%95%B0%E6%8D%AE2.png"><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E5%AF%BC%E5%87%BA%E8%A1%A8%E6%95%B0%E6%8D%AE3.png"></p>
<p>最终生成一个有许多insert语句的脚本。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E8%A1%A8%E6%95%B0%E6%8D%AE%E6%8F%92%E5%85%A5%E8%84%9A%E6%9C%AC.png"></p>
<p>打开脚本，在首行加上一句。如果不加，那么DBeaver就会把每个字符读取为十六进制数，导致报错。比如：Incorrect string value: ‘\xAE\xE9\x80\x9A\xE8\xA7…’ for column ‘role_name’ at row 1</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="type">character</span> <span class="keyword">set</span> utf8;</span><br></pre></td></tr></table></figure></li>
<li><p>右击需要导入数据的数据库，选中刚才生成的脚本，并点击开始</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC1.png"></p>
</li>
</ol>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202212/%E6%89%A7%E8%A1%8C%E8%84%9A%E6%9C%AC2.png"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/03/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/11/03/Nginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%AB%99/" itemprop="url">Nginx反向代理访问第三方网站（HTTPS）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-11-03T11:15:33+08:00">
                2022-11-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>物理机：Windows 10</p>
<p>虚拟机：Centos 7（安装Nginx）</p>
<h3 id="编译安装Nginx"><a href="#编译安装Nginx" class="headerlink" title="编译安装Nginx"></a>编译安装Nginx</h3><p>参考文章（配置nginx.conf的步骤跳过）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/rookie23rook/article/details/118112082">点击跳转</a></p>
<h3 id="配置nginx-config（建议新建一个config文件）"><a href="#配置nginx-config（建议新建一个config文件）" class="headerlink" title="配置nginx.config（建议新建一个config文件）"></a>配置nginx.config（建议新建一个config文件）</h3><p>配置http块中的示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 443 ssl;</span><br><span class="line">    server_name         bd.com;</span><br><span class="line">    ssl_certificate     &#x2F;keys&#x2F;test.crt;</span><br><span class="line">    ssl_certificate_key &#x2F;keys&#x2F;test.key;</span><br><span class="line">    ssl_protocols       TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">    ssl_ciphers         HIGH:!aNULL:!MD5;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">            resolver 114.114.114.114; # dns server</span><br><span class="line">            proxy_pass https:&#x2F;&#x2F;www.baidu.com&#x2F;;</span><br><span class="line">            proxy_set_header Host www.baidu.com;</span><br><span class="line">            proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">            proxy_set_header REMOTE-HOST $remote_addr;</span><br><span class="line">            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>server_name：在hosts中配置<code>bd.com</code>和Nginx的IP绑定后，使用<code>bd.com</code>作为域名访问Nginx，请求则会进入server_name为<code>bd.com</code>的server块中进行处理</p>
<p>ssl_certificate：证书位置（下个步骤讲如何生成）</p>
<p>ssl_certificate_key：证书key位置（下个步骤讲如何生成）</p>
<p>resolver：DNS服务器地址</p>
<p>proxy_set_header Host：设置Host请求头，想知道某个网站的Host，可以在浏览器打开F12页面查看。有些网站可能使用安全策略，判断Host是否是自己的域名，最终确定是否需要拦截请求。</p>
<h3 id="生成证书"><a href="#生成证书" class="headerlink" title="生成证书"></a>生成证书</h3><p>想要Nginx转发HTTPS请求，需要使用HTTPS先访问Nginx，而Nginx能被HTTPS访问到的前提是需要证书。</p>
<p>生成证书的方式参考该文章（生成.crt和.key文件）：<a target="_blank" rel="noopener" href="https://developer.aliyun.com/article/660820">点击跳转</a></p>
<h3 id="配置hosts"><a href="#配置hosts" class="headerlink" title="配置hosts"></a>配置hosts</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">192.168.15.130 bd.com</span><br></pre></td></tr></table></figure>
<p>hosts是在Windows上，该IP是本人虚拟机的IP，所以这需要自己设置为Nginx所在的IP。</p>
<h3 id="启动Nginx（Centos-7）"><a href="#启动Nginx（Centos-7）" class="headerlink" title="启动Nginx（Centos 7）"></a>启动Nginx（Centos 7）</h3><p>使用cd命令切换到Nginx根目录，然后使用如下命令启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 默认使用nginx.conf</span><br><span class="line">sbin&#x2F;nginx</span><br><span class="line"></span><br><span class="line"># 使用自定义配置文件</span><br><span class="line">sbin&#x2F;nginx -c 配置文件位置</span><br></pre></td></tr></table></figure>
<h3 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h3><p>在Windows的浏览器上输入：<a target="_blank" rel="noopener" href="https://bd.com/">https://bd.com</a></p>
<p>第一次访问会提示</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202211/%E4%B8%8D%E6%98%AF%E7%A7%81%E5%AF%86%E8%BF%9E%E6%8E%A5.png"></p>
<p>点击高级-&gt;继续前往即可访问页面</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202211/%E8%AE%BF%E9%97%AE%E9%A1%B5%E9%9D%A2.png"></p>
<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><p>如果提示网站无响应，则可能是Nginx所在机器的防火墙没有开启443端口，直接开启即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/09/kafka%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/09/kafka%E6%B6%88%E6%81%AF%E6%B6%88%E8%B4%B9/" itemprop="url">Kafka消息消费</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-09T16:53:45+08:00">
                2022-03-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>kafka消费消息，离不开<strong>主题(topic)</strong> ，<strong>分区(partition)</strong> ， <strong>消费者组(用groupId区分)</strong> 和 <strong>消费者(consumer)</strong> 这四个名词。</p>
<p>消费流程：</p>
<ol>
<li><p>创建<strong>消费者</strong>，并指定<strong>消费者组</strong>，和订阅<strong>主题</strong>。</p>
</li>
<li><p><strong>消费者</strong>从<strong>主题</strong>的<strong>分区</strong>中拉取消息。</p>
</li>
</ol>
<p>以上就是Kafka中消息消费的流程。先建立下概念，再往下看名词的解释。</p>
<p><strong>主题(topic)</strong> 和 <strong>分区(partition)</strong></p>
<p>Kafka的主题是一个逻辑上的概念，可分为多个分区，分区就是物理上存储消息的地方，可分布到不同的机器上，扩展性强。</p>
<p><strong>消费者组</strong> 和 <strong>消费者(consumer)</strong></p>
<p>消费者组也是逻辑上的概念，一个消费者组可以包含多个消费者。消费者组会均衡地为组内消费者分配分区，每个<strong>分区</strong>只由<strong>消费者组</strong>中一个<strong>消费者</strong>消费。每个消费者组，都会维护在各个分区的消费情况，包括消费偏移量(offset)。</p>
<p>下面是网上关于分配分区的图：</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202203/Kafka%E6%B6%88%E8%B4%B9%E8%80%85%E7%BB%84%E5%88%86%E9%85%8D%E5%88%86%E5%8C%BA.png" alt="img"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/04/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81%E7%AE%97%E6%B3%95/" itemprop="url">微服务限流算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-04T17:04:53+08:00">
                2022-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>常用的微服务限流算法有以下4种：</p>
<ol>
<li><p>固定窗口算法/计数法</p>
<p>该算法简单地限制某个时间范围内的请求总数，请求一进来，只要在某个时间范围内，请求数&lt;=请求总数，则放行，否则拦截。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95.png"></p>
<p>假设时间范围为1分钟，每分钟限制最高100次请求，则在0分钟到1分钟内的请求不得超过100次，否则就会被限流。</p>
<p>这种方法实现起来最简单，但是会有边界问题导致限流失灵，请看下面这种情况。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E5%9B%BA%E5%AE%9A%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E7%BC%BA%E9%99%B7.png"></p>
<p>如果在第一分钟前几秒和后几秒，各请求100次，其他时间不请求。那么，现在两个1分钟内的请求数都没超过100，结果是请求都被放行了，但是，在这短短10秒不到的时间里，却请求了200次，远大于每分钟100次。</p>
<p>对于解决这种边界问题，我们可以使用<strong>滑动窗口算法</strong>。</p>
</li>
<li><p>滑动窗口算法</p>
<p>该算法跟<strong>固定窗口算法</strong>相似，同样是计算某个时间段内请求总数，请求一进来，只要在某个时间范围内，请求数&lt;=请求总数，则放行，否则拦截。</p>
<p>不同的点在于，滑动窗口算法把时间范围划分成若干块小时间段。</p>
<p>假设时间范围为1分钟，按15秒为一个小时间段，那么在前1分钟内的请求，会根据请求时间，落入4个小时间段内，且每次有请求进来，都会先算这1分钟内（红框内）的请求总数，再决定是否放行。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95.png"></p>
<p>若<code>00:01:10</code>有一个新的请求，则红框往右移动一格，再计算红框内请求总数，再决定是否放行。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%952.png"></p>
<p>假如在第一分钟前几秒和后几秒，各请求100次（绿框），其他时间没有请求，那么这个时候，红框内的请求总数超过了100次，就把多出的100次请求拦截掉了，解决了<strong>固定窗口算法</strong>的边界问题。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3%E7%9A%84%E9%97%AE%E9%A2%98.png"></p>
</li>
<li><p>漏桶算法</p>
<p>该算法由一个请求队列组成，请求来了，先判断请求队列是否有位置，有则入队，否则拦截请求。其中请求队列入队速度快慢不定，出队速度均匀。</p>
<p>该算法主要是控制单位时间内的请求总量，无论单位时间内请求入队多少，都不影响出队速度，有削峰填谷的效果。个人认为这跟消息队列有异曲同工之妙，适合顺时高并发的场景，比如秒杀和0点签到。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E6%BC%8F%E6%A1%B6%E7%AE%97%E6%B3%95-%E4%BF%AE%E6%94%B9.png"></p>
<p>假设请求队列的容量为100，每次有请求进来时，都先判断队列是否还有位置，有则请求入队，否则拦截请求。已经在队列中的请求，会以给定的速率被放行，比如一分钟放行n条。</p>
</li>
<li><p>令牌桶算法</p>
<p>该算法由一个令牌队列（令牌桶）构成，且以均匀的速度生成令牌并放入令牌队列，入队前也是先检查是否有位置，有则令牌入队，否则丢弃令牌。</p>
<p>请求过来的时候，先从令牌队列中获取令牌，获取成功则放行请求，否则拦截请求。</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/202208/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95.png"></p>
<p>令牌桶和漏桶算法很相似，其中的区别可以看这篇文章：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/news/841709">https://cloud.tencent.com/developer/news/841709</a></p>
</li>
</ol>
<p>以上四种就是常见的限流算法，不过这些算法都是单机版，如果想要在分布式系统中使用，就需要把一些信息存到中间件中或者使用分布式限流中间件。</p>
<p>要存入中间件的信息如，令牌桶算法的存放令牌的队列，就要存到中间件中。分布式限流中间件如<a target="_blank" rel="noopener" href="https://github.com/alibaba/Sentinel/wiki/%E4%BB%8B%E7%BB%8D">Sentinel</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/12/14/%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8C%E7%BB%91%E5%AE%9A0.0.0.0%E5%92%8C127.0.0.1%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/12/14/%E5%90%AF%E5%8A%A8%E7%BD%91%E7%BB%9C%E7%A8%8B%E5%BA%8F%E5%90%8E%EF%BC%8C%E7%BB%91%E5%AE%9A0.0.0.0%E5%92%8C127.0.0.1%E7%9A%84%E5%8C%BA%E5%88%AB/" itemprop="url">启动网络程序后，绑定0.0.0.0和127.0.0.1的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-12-14T17:18:27+08:00">
                2021-12-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>我在写一个tcp程序，放到云服务器运行的时候，发现通过公网ip访问不到。</p>
<p>我第一时间检查了安全组和服务器的防火墙，发现没问题。</p>
<p>然后我用netstat -tnlp 命令，发现该程序绑定了127.0.0.1:xxxx。</p>
<p>后来我百度一轮，发现需要修改代码，让程序绑定到0.0.0.0:xxxx。代码修改完，运行程序，发现可以用公网ip访问了。</p>
<h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><ol>
<li><p>为什么绑定127.0.0.1不能被公网ip访问，而0.0.0.0可以？</p>
</li>
<li><p>这两个地址有什么区别？</p>
</li>
</ol>
<h3 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h3><p>我带着疑问，又百度了一番，答案总结如下：</p>
<p>127.0.0.1 表示回环地址，如果服务器上的程序绑定了该ip，那就只能通过该ip去访问。</p>
<p>0.0.0.0 表示的是本机上所有ip地址。比如我的云服务器，有内网ip，公网ip和回环ip。所以，服务器上的程序，绑定0.0.0.0之后，可以通过以上3个ip访问。</p>
<p>所以，云服务器的tcp程序绑定了0.0.0.0之后，可以通过公网ip访问，而绑定127.0.0.1不能。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/11/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/11/19/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6/" itemprop="url">Java类加载双亲委派机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-11-19T15:10:15+08:00">
                2021-11-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>类加载机制</strong></p>
<p>Java虚拟机把描述类的数据从Class文件加载进内存，并对数据进行校验，转换解析和初始化，最终形成可以呗虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p>
<p>虚拟机设计团队把类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这动作的代码模块成为“类加载器”。</p>
<p>对于任意一个java类，它本身和加载它的那个加载器共同确立了该类在jvm中的唯一性。</p>
<p>什么意思？就是同一个jvm中，如果要比较两个类是否是同一个类，要先确定这两个类是否由同一个类加载器加载。假如两个类的字节码相同，但是类加载器不同，那么就不是同一个类。</p>
<p><strong>双亲委派模型</strong></p>
<p>对于jvm来说，类加载器分启动类加载器（BootStrap ClassLoader）和其他类加载器。启动类加载器是jvm的一部分。另外的类加载器都继承自java.lang.ClassLoader，在jvm外部实现。</p>
<p>对于开发人员来说，类加载器可以再细分，大部分的开发人员都会用以下三种：</p>
<ol>
<li>启动类加载器（Bootstrap ClassLoader）：这个类加载器复杂将存放在 JAVA_HOME/lib 目录中的，或者被-Xbootclasspath 参数所指定的路径种的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录下也不会重载）。</li>
<li>扩展类加载器（Extension ClassLoader）：这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责夹杂JAVA_HOME/lib/ext 目录下的，或者被java.ext.dirs 系统变量所指定的路径种的所有类库。开发者可以直接使用扩展类加载器。</li>
<li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader 实现。由于这个类加载器是ClassLoader 中的getSystemClassLoader方法的返回值，所以也成为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用中没有定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ol>
<p>类加载器关系如图</p>
<p><img src="https://xtf-blog-pic.oss-cn-beijing.aliyuncs.com/xtf-blog-pic/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E5%8F%8A%E8%AF%BB%E5%8F%96%E8%B7%AF%E5%BE%84.jpg" alt="img"></p>
<p>类加载器的关系成为类加载器的双亲委派模型。</p>
<p>双亲委派模型要求：除了顶层的类加载器外，其余类加载器加载类时，都会把加载任务先交给父类加载器加载（加载器与父类加载器不是继承的关系，通过组合实现对父类加载器方法的复用），如果父类加载器找不到该类，无法完成类加载的时候，子类加载器才会自己加载。</p>
<p>其中，AppClassLoader的父类加载器是ExtClassLoader，ExtClassLoader的父类加载器是BootStrap ClassLoader。</p>
<p>例子：classpath中定义一个A类，那么在加载A的时候使用的是AppClassLoader，这个类加载器遵循双亲委派原则，又会将加载A的任务交给BootStrap ClassLoader进行加载。BootStrap在目录中找不到A-&gt;ExtClassLoader找不到A-&gt;AppClassLoader找到并加载A</p>
<p><strong>如果我不遵循这个要求会怎么样？</strong></p>
<p>如果开发者在classpath中自己新建了一个java.lang.Object类，现在不遵循双亲委派机制，这时候每个类加载器都会加载各自目录下的类。</p>
<p>那么，现在AppClassLoader就会加载classpath中的java.lang.Object类。然而BootStrap加载器在前面也加载了一个java.lang.Object类。那么这个时候，整个java项目就很凌乱了，jvm中出现了多个不同的Object。</p>
<p><strong>总结</strong></p>
<p>双亲委派机制可以防止jvm中java基础类的重复加载。越基础的类，由越上层的类加载器加载。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/08/10/MySql%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/08/10/MySql%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95%E5%92%8C%E9%9D%9E%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/" itemprop="url">MySql聚集索引和非聚集索引</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-08-10T12:23:08+08:00">
                2021-08-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文说的MySql索引，都是用InnoDB引擎。</p>
<p>InnoDB有两大类索引：<strong>聚集索引</strong>和<strong>普通索引</strong></p>
<p><strong>聚集索引</strong>：聚集索引的叶子节点存储行记录，因此，InnoDB必须要有且只有一个聚集索引。表定义了主键，那么主键就是聚集索引。因为聚集索引可以直接定位到行，所以用主键搜索很快。</p>
<p><strong>普通索引</strong>：普通索引的叶子节点存储数据对应的主键，使用索引列的值做索引key</p>
<p>说到这两种索引，就不得不说回表的事。</p>
<h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>回表就是一次查询中，where条件的字段命中了索引，但是，select的字段中，有一些不是where条件的字段。</p>
<p>这就造成了，查询先走普通索引，查出相应数据的主键id。然后根据这些主键id，在聚集索引里，查出相应数据。</p>
<p>这既是回表。加入普通索引中的值比较多，那么在回表的时候，就会增加使用主键查询数据的次数，增加io压力。</p>
<h3 id="索引覆盖"><a href="#索引覆盖" class="headerlink" title="索引覆盖"></a>索引覆盖</h3><p>如果上述回表，使得查询速度慢得不能接受，就得触发索引覆盖去优化一下了。</p>
<p>索引覆盖如何触发？select的字段都是where条件中的索引字段。</p>
<p>比如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> wechat_id <span class="keyword">from</span> t_user</span><br><span class="line"><span class="keyword">where</span> wechat_id <span class="operator">=</span> <span class="string">&#x27;1511&#x27;</span> <span class="comment">-- wechat_id建立了索引</span></span><br></pre></td></tr></table></figure>
<p>上述sql语句触发索引覆盖后，可以在索引树中直接查到wechatid信息，无需回表，提高了查询效率。可以使用explain分析语句，如果extra列显示using index，那就是触发了索引覆盖。</p>
<h3 id="关于回表的思考"><a href="#关于回表的思考" class="headerlink" title="关于回表的思考"></a>关于回表的思考</h3><p>发现在很多查询业务中，回表都会存在的。</p>
<p>因为查询条件往往比查出来的字段要少，这样一般是不会触发索引覆盖的。</p>
<p>就算查询条件等于查出来的字段，但是只用到了其中几个查询条件，这个时候，也是不会触发索引覆盖的。</p>
<p>那么有没办法解决呢？有，我觉得可以换个思考方向，可以先用条件查出符合的数据的主键id，然后通过id连表查数据。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> l.<span class="operator">*</span> <span class="keyword">from</span> t_log l</span><br><span class="line"><span class="comment">-- 该子查询的where字段都有索引，该子查询命中了索引。因为普通索引有记录主键id，所以select id属于索引里的字段，所以触发了索引覆盖，不用回表。所以子查询很快找出了符合的数据</span></span><br><span class="line"><span class="keyword">join</span>(</span><br><span class="line">	<span class="keyword">select</span> id <span class="keyword">from</span> t_log <span class="comment">-- 查询</span></span><br><span class="line">	<span class="keyword">where</span> app_key <span class="operator">=</span> <span class="string">&#x27;10000001&#x27;</span></span><br><span class="line">	<span class="keyword">and</span> mobile <span class="operator">=</span> <span class="string">&#x27;18048018581&#x27;</span></span><br><span class="line">	limit <span class="number">10000</span>, <span class="number">10</span></span><br><span class="line">) l1 <span class="keyword">on</span> l.id <span class="operator">=</span> l1.id</span><br></pre></td></tr></table></figure>
<p>不过，如果数据太多，这种索引覆盖也没辙了。比如limit 1000000, 10，那么子查询就很慢了，10s都没出结果。这种情况就要优化了，具体是升级机器配置，还是分库分表就具体情况具体分析了。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/15/%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B%E7%9A%84%E7%90%86%E8%A7%A3/" itemprop="url">线程和协程的理解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-15T23:42:47+08:00">
                2021-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="协程概念"><a href="#协程概念" class="headerlink" title="协程概念"></a>协程概念</h3><p>协程（纤程）属于轻量级线程，由程序在用户空间创建和管理。对于CPU来说，协程就是单线程，故切换协程时，不存在线程上下文切换，可以节省CPU的开销。</p>
<p>线程，在内核空间创建和管理，由操作系统调度，一个CPU同时只能运行一个线程（现代CPU超线程技术可以在一个CPU同时运行两个线程）。</p>
<h3 id="协程和线程的对应关系"><a href="#协程和线程的对应关系" class="headerlink" title="协程和线程的对应关系"></a>协程和线程的对应关系</h3><p>假如一个程序开了多个线程，那么操作系统就会开多个线程与程序的线程一一对应，并且在调度线程的时候，需要进行线程切换，这个是需要消耗CPU资源的。</p>
<p>假如用的是多个协程，系统中可能只开一个线程与多个协程对应，是1:n的关系。这时，多协程可在单个CPU上做并发操作，而且切换协程不需要切换线程上下文，所以CPU资源消耗也少了。</p>
<h3 id="那是不是协程就比线程好呢？"><a href="#那是不是协程就比线程好呢？" class="headerlink" title="那是不是协程就比线程好呢？"></a>那是不是协程就比线程好呢？</h3><p>技术上，没有哪项技术能完爆另一项技术，而是要分场景讨论，按场景来做比较。</p>
<p>在IO密集型应用上，协程比线程能更有效地使用CPU。如果代码里需要IO操作，就需要阻塞等待操作完成。如果是开启线程执行代码，那么线程在等待的时候，CPU将不做其他操作，这样就浪费了CPU算力。如果是开启协程执行代码，那么。由于切换协程的消耗小，我们就可以通过算法，让等待的CPU执行其他协程，这么一来，就可以更有效地使用CPU。</p>
<p>在CPU密集型应用上，线程比协程能更有效地使用多个CPU，因为协程本质就是单线程。</p>
<h3 id="后话"><a href="#后话" class="headerlink" title="后话"></a>后话</h3><p>以本人的观察，目前的业务系统主要都是CRUD，基本都是IO密集型的代码，CPU密集型的代码占少数。</p>
<p>所以协程，以及以简便开启协程、高并发为卖点的Go语言会被这么多互联网公司看中，还是有一定原因的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/07/15/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="写BUG小能手">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/15/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/" itemprop="url">进程和线程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-15T23:13:55+08:00">
                2021-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程就是操作系统分配资源的基本单位，也就是给一个程序分配一系列资源。</p>
<h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>线程是操作系统执行的基本单位。</p>
<h3 id="进程和线程关系？"><a href="#进程和线程关系？" class="headerlink" title="进程和线程关系？"></a>进程和线程关系？</h3><p>线程是进程中可并行执行的多个分支。</p>
<p>可见，多条线程一起工作，效率会比单线程高。但是如果线程数太多，其效率不一定比线程数烧的时候高，因为其中涉及到线程切换。</p>
<h3 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h3><p>线程切换具体是这样的：程序计数器记录下当前线程执行的位置，然后把位置信息写入寄存器，再由寄存器放到缓存或内存中，然后执行另外的线程。执行完另外的线程后，再读取刚刚记录的位置，继续执行。</p>
<p>线程切换要用到程序计数器，寄存器之类的，是需要消耗cpu资源的，如果线程过多，则cpu的资源可能大部分都被用来切换线程了，这就降低了cpu的效率。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">&lt;i class&#x3D;&quot;fa fa-angle-right&quot;&gt;&lt;&#x2F;i&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xuetaofeng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
